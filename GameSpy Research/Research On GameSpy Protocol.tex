\documentclass[oneside,titlepage,a4paper]{Definition/retrospy} %book,article,report,letter



\begin{document}

\title{\Huge\textbf{Research On GameSpy Protocol}} 
\author{Arves100, xiaojiuwo}


%\date{} %%如果没有这句，会生成时间

\maketitle  %%生成书名

\tableofcontents  %%生成目录

%\mainmatter %%表示文章的正文部分，在生成目录后将从第一页开始
\part{Introduction}

\chapter{History of GameSpy}

\chapter{Related Works}


\part{General Information}
In this chapter we describe the structure of GameSpy SDK and GameSpy servers.
\chapter{SDK Module}
GameSpy SDK contains of  16 modules.
	\begin{itemize}
		\item Brigades
		\item Chat
		\item Presence \& Messaging
		\item CDKey
		\item Stats \& Tracking
		\item Persistent Storage
		\item Transport
		\item NAT Negotation
		\item Peer to Peer communication
		\item Patching \& Tracking
		\item Server Browser
		\item Query \& Reporting
		\item SAKE Persistent Storage
		\item ATLAS Competition
		\item Voice Chat
		\item Web Authentication
	\end{itemize}

\chapter{GameSpy Back-end Servers}
\par GameSpy back-end servers are list as follows.
	\begin{itemize}
		\item GameSpy Presence Connection Manager (GPCM)
		\item GameSpy Presence Search Player(GPSP)
		\item GameSpy Query and Report (QR)
		\item GameSpy Server Browser (SB)
		\item GameSpy Stats \& Tracking (GStats)
		\item GameSpy Chat
		\item GameSpy NAT Negotation (NatNeg)
		\item GameSpy CDKey 
		\item GameSpy Web Services
		\item GameSpy SAKE Storage (SAKE)
	\end{itemize}

\chapter{Access Sequence of The Client}
If a user want to use GameSpy service, the access sequence is listed in Figure~\ref{The access sequence of client} and we describe the detail below.
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
	\begin{tikzpicture}  [node distance = 2cm, auto,transform shape]
	\node[block] (gpcm) {GPCM};
	%%%%%%%%%%%right nodes%%%%%%%%%%
	\node[block, right= of gpcm](gpsp){GPSP};
	\node[block, right= of gpsp](qr){QR};
	\node[block, below= of qr](sb){SB};
	%%%%%%%%%%%left nodes%%%%%%%%%%%
	\node[block,below= of gpcm](cdkey){CDKey};

		%%%%%%%%%%%bottom nodes%%%%%%%%
	\node[block, below= of gpsp] (client) {Client};  
	\node[block, below= of client](gstats){GSTATS};
	\node[block, right= of gstats](webserver){WebServer};
		\node[block, left= of gstats](chat){CHAT};
	%%%%%%%%%%%top nodes%%%%%%%%%%
	\node[block, above= of gpcm](gameserver){Game Server};
	
	
	%%%%%%%%%%%lines%%%%%%%%%%%%%
	\draw[line] (client)--node [midway, above] {\circled{\small{2}}}(gpcm);
	\draw[line](client)--node [midway, left] {\circled{\small{2}}}(gpsp);
	\draw[line](client)--node [midway, above] {\circled{\small{3}}}(cdkey);
	\draw[line](client)--node [midway, above] {\circled{\small{4}}}(chat);
	\draw[line](client)--node [midway, above] {\circled{\small{1}}} (qr);
	\draw[line](client)--node [midway, above] {\circled{\small{7}}}(sb);
	
	\draw[line](client)--node [midway, left] {\circled{\small{5}}}(gstats);
	\draw[line](client)--node [midway, above] {\circled{\small{5}}}(webserver);
		
	\draw[line](sb)--(qr);
	
	\draw[line](gameserver)--node [midway, above] {\circled{\small{6}}}(qr);
	\draw[line](client)--node [midway, right] {\circled{\small{8}}}(gameserver);
	\draw[line](gameserver.west) to [in=190,out=190] node [midway, right] {\circled{\small{9}}}(cdkey.west);


	\end{tikzpicture}  
}
	\caption{The access sequence of client}
	\label{The access sequence of client}
\end{figure}

\begin{figure}[H]
	\centering
	\scalebox{0.7}{
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst{GPCM}{GPCM}{}
		\newinst{GPSP}{GPSP}{}
		\newinst{CDKey}{CDKey}{}
		\newinst{CHAT}{CHAT}{}
		\newinst{QR}{QR}{}
		\newinst{SB}{SB}{}
		\newinst{GSTATS}{GSTATS}{}
		\newinst{WebServer}{WebServer}{}
		\begin{call}
			{Client}{}{GPCM}{}
		\end{call}
		\begin{call}
			{Client}{}{GPSP}{}
		\end{call}
		\begin{call}
		{Client}{}{CDKey}{}
		\end{call}
		\begin{call}
		{Client}{}{CHAT}{}
		\end{call}
		\begin{call}
		{Client}{}{QR}{}
		\end{call}
		\begin{call}
		{Client}{}{SB}{}
		\begin{call}
		{SB}{}{QR}{}
		\end{call}
		\end{call}
			\begin{call}
	{Client}{}{GSTATS}{}
\end{call}
			\begin{call}
	{Client}{}{WebServer}{}
	\begin{call}
		{WebServer}{}{GPCM}{}
	\end{call}
\end{call}
	\end{sequencediagram}
}
	\caption{Login diagram}
	\label{Login diagram}
\end{figure}

\begin{flushleft}
\textbf{Explanation of access sequence}
\end{flushleft}

\begin{enumerate}
	\item Client checks in QR server, which tells client GameSpy back-end server status.
	\item Client accesses GPCM or GPSP to check their account and login.
	\item Client accesses to CDKey to verify his cd-key in login phase.
	\item Client logins to Chat server.
	\item Client retrieves player data(level, exp, etc.) from GStats(old game use this server to store player data, new game use Web Server to store player data).
	\item When a game server is launched it will send heartbeat to QR server to tell QR its information.
	\item Client accesses to SB to search online game server.
	\item Client logins to game server with his information and cd-key.
	\item Game server will check his cd-key by accessing to CDKey server, after every information is verified, client should be able to play their game.
\end{enumerate}


\chapter{Basic Description of Protocol}
In this part, we describe some of the basic patterns that are used in all GameSpy servers.

\section{String Pattern}
We first introduce the pattern of the string, which is used to make up a request and response.
The following servers do use the pattern: Presence Connection Manager, Presence Search Player, GameSpy Status and Tracking, CD-Key, Query Report(version 1)
This kind of string represents a value in a request and response sent by the client or the server as Table \ref{String pattern}.\\


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs \textbf{key}\tbs\textbf{value}\tbs& The key is \textbf{key}, the value of the key is \textbf{value}  \\ 
 		\hline
	\end{tabular} 
	\caption{String pattern}
	\label{String pattern}
\end{table}
There are two kind of patterns the first one is value string, the second one is command string.
\textbf{Value String}
This kind of string represents a key value pair in the request or response string, it has a key and a correspond value as shown in Table~\ref{Value string}.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs pid\tbs  13\tbs & The key is \textbf{pid}, the value of the \textbf{pid} is 13  \\ 
		\hline
		\tbs userid\tbs  0\tbs & The key is \textbf{userid}, the value of the  \textbf{userid} is 0  \\ 
		\hline
	\end{tabular} 
	\caption{Value string}
	\label{Value string}
\end{table}


\textbf{Command String}

This kind of string represents a command in a request sends by the client or the server as Table \ref{Command string}.
The command will end with $ \backslash \backslash $ or $ \backslash $ depends on whether run at the server-side or client-side.


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline 
		\textbf{String}&\textbf{Description}  \\ 
		\hline 
		\tbs command\tbs\tbs& This is a command \\ 		
		\hline
	\end{tabular} 
	\caption{Command string}
	\label{Command string}
\end{table}


\part{GameSpy Presence \& Messaging}
\par Presence \& Messaging system allows a game to add account authentication or registration, which includes a profile where personal information could be stored (such as email, first name), a friend list (called buddies), private messages.
\par GameSpy Presence contains two servers, GameSpy Presence Connection Manager (GPCM) and GameSpy Presence Search Player (GPSP).
GPCM is a server that manages the profiles (such as login, storing the profile information).

\chapter{Common Information}
In this section we describe the common information, methods, techniques that GPCM and GPSP have.
\section{Server IP and Ports}
Table \ref{IP and Ports for GameSpy Presence Servers} are the  IP and Ports of GPCM and GPSP that client or game connect to.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		GPCM&gpcm.gamespy.com&29900 (tcp) \\ 
	 	\hline 
		GPSP&gpsp.gamespy.com&29901 (tcp)\\
		\hline
	\end{tabular} 
\caption{IP and Ports for GameSpy Presence Servers}
\label{IP and Ports for GameSpy Presence Servers}

\end{table}

\chapter{GameSpy Presence Connection Manager}


\section{Request Command of GameSpy Presence Connection Manager}
Table \ref{Request For GameSpy Presence Connection Manager} lists the request (known by us) that clients send to GameSpy Presence Connection Manager server (GPCM).
\begin{table}[H]
	\centering
	\begin{tabular}{B}
		\hline 
		\textbf{Commands}&\textbf{Description}  \\ 
		\hline 
		 inviteto& Invite friends\\ 		
		\hline 
		 login &Login to GPCM \\
		\hline
 		 getprofile &	Get the profile of a player (including your own)\\
 		\hline
		 addbuddy & Add a player to my friend list \\
		\hline
		delbuddy  & Delete a player from my friend list \\
		\hline
		updateui & Update login information (email, password) \\
		\hline
		updatepro & Update my profile such as first name, last name, gender etc. \\
		\hline
		 logout & Logout manually by user\\
		\hline
		status& Update the status of a user (Such as what game is the player playing) \\
		\hline
		ka & Keep client or session alive \\ \hline
		 bm & Message command \\
		\hline 
		 blk & Block list \\ \hline
		bdy  & Friend list \\ \hline
		 lt & Login ticket \\ \hline
	\end{tabular} 
	\caption{Request For GameSpy Presence Connection Manager}
	\label{Request For GameSpy Presence Connection Manager}
\end{table}

Error response string for (GPCM, GPSP):
\begin{equation}
\begin{split}
\backslash error \backslash\backslash err \backslash < error code > \backslash fatal\backslash\backslash errmsg \backslash < error message > \backslash id\backslash 1 \backslash final \backslash
\end{split}	
\end{equation}

\section{GPI Connect Module}
\subsection{Login}
We show the login communication diagram in Fig~\ref{Login diagram}

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
	\newthread{Client}{Client}{}
	\newinst[5]{GPCM}{GPCM}{}
	\begin{call}
		{Client}{Connect}{GPCM}{Send challenge}
	\end{call}
\begin{call}
		{Client}{Send challenge response}{GPCM}{Accept/reject}
\end{call}
\end{sequencediagram}
\caption{Login diagram}
\label{Login diagram}
\end{figure}

\begin{flushleft}
	\textbf{Server initial Challenge:\\}
\end{flushleft}
When a client is connected to GPCM server, GPCM Server will send a challenge to client. The challenge string shows in \ref{server challenge1} and \ref{server challenge2}. However we do not know the correct functionality of \ref{server challenge2}.

\begin{mybox}[label=server challenge1]
	\tbs lc\tbs 1\tbs challenge\tbs<challenge string>\tbs final\tbs
\end{mybox}

\begin{mybox}[label=server challenge2]
	\tbs lc\tbs 1\tbs challenge\tbs<challenge string>\tbs nur\tbs\tbs userid\tbs<user id>\\
	\tbs profileid\tbs<profile id>\tbs final\tbs
\end{mybox}

\begin{itemize}
	\item{challenge: }The challenge string sent by GPCM.
\end{itemize}
\begin{table}[H]
	\centering
	\begin{tabular}{A}
		
		\hline 
		\textbf{Keys}&\textbf{Description}&\textbf{Type}  \\ 
		\hline 
		challenge & The challenge string sended by GameSpy Presence server&String \\ 		
		\hline 
		nur & ? Create new user delimiter &\\
		\hline 
		userid&The userID of the profile & Uint\\	\hline 
		profileid&The profileID & Uint\\	\hline 
	\end{tabular} 
	\caption{The first type login response}
	\label{The first type login response}	
\end{table}	

\begin{flushleft}
	\textbf{Client Login Request:\\}
\end{flushleft}
There are three ways of login:
\begin{itemize}
	\item AuthToken: Logging using an alphanumeric string that represents an user.
	\item 	UniqueNick: Logging using a nickname that is unique from all the players.
	\item User: Logging with nickname, email and password.
\end{itemize}
We show the common part of login request in \ref{Common string}

\begin{mybox}[label=Common string]
	\tbs login\tbs\tbs challenge\tbs<challenge string>\tbs $\star$\tbs userid\tbs<user id>\\
	\tbs profileid\tbs <profile id>\tbs partnerid\tbs<partner id>\\
	\tbs response\tbs<challenge response string>\tbs firewall\tbs<firewall flag>\\\tbs port\tbs<port>\tbs productid\tbs<product id>\tbs gamename\tbs<game name>\\\tbs sdkrevision\tbs<sdk revision number>\tbs quiet\tbs<quiet mode flag>\\\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

Where the value of $ \star $ in \ref{Common string} depending on which login method user is using.

\begin{mybox}
	\tbs authtoken\tbs<authentication token>\tbs\\
	\tbs uniquenick\tbs<uniquenick name>\tbs\\
	\tbs user\tbs<nick name+@+email>\tbs
\end{mybox}
\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline
		\textbf{Keys} & \textbf{Description} & \textbf{Type}	                                                                          \\ \hline
		login& The login command which use to identify the login request of client&\\ \hline
		challenge  & The user challenge used to verify the authenticity of the client     & See \ref{Login Proof Challenge Gerneration Algorithm}                                                                                                        \\ \hline
		authtoken  & The token used to login (represent of an user)        & String\\ \hline
		uniquenick  & The unique nickname used to login       & String                                                                                                                                                                 \\ \hline
		user     & The users account (format is NICKNAME@EMAIL)           &String\\ \hline
		userid    & User id              &      Uint                                                                                                                  \\ \hline
		profileid  & Profile id          &      Uint                                                                                                                  \\ \hline
		partnerid  & This ID is used to identify a backend service logged with gamespy.(Nintendo WIFI Connection will identify his partner as 11, which means that for gamespy, you are logging from a third party connection) & Uint\\ \hline
		response   & The client challenge used to verify the authenticity of the client     & String                                                                                                                                   \\ \hline
		firewall   & If this option is set to 1, then you are connecting under a firewall/limited connection & Uint\\
		\hline
		port& The peer port (used for p2p stuff)&Uint \\\hline
		productid  & An ID that identify the game you're using            &Uint\\ \hline
		gamename   & A string that rapresents the game that you're using, used also for several activities like peerchat server identification&string \\ \hline
		
		namespaceid & Distinguish same nickname player   &Uint                                                                                                                                                                                                     \\ \hline
		sdkrevision & The version of the SDK you're using&Uint \\ \hline
		quiet    & quite flag mode used in status buddy info \ref{Buddy Status Info} & Uint\\ \hline
		lt& The login ticket used for login into SAKE&String 25 \\ \hline
		id& The operation number&Uint\\ \hline
	\end{tabular} 
	\caption{Login parameter string}
	\label{Login parameter string}
\end{table}


\ServerResponse

When received client's login request, server check the challenge and proof. if client pass the check, server will first send response\ref{server login response lc2} and then it will send friend list friend status, message, add friend request.

\begin{mybox}[label=server login response lc2]
	\tbs lc\tbs 2\tbs sesskey\tbs<session key>\tbs userid\tbs<user id>\tbs uniquenick\tbs <unique nick>\tbs lt\tbs<login ticket>\tbs<challenge proof>\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		sesskey & The session key, which is a integer rapresentating the client connection&Uint \\ 		
		\hline 
		userid & The userID of the profile&Uint \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		uniquenick&The logged in unique nick &String\\	\hline 
		lt& The login ticket, unknown usage&String\\\hline
		proof& The proof is something similar to the response but it vary&String\\\hline
	\end{tabular} 
	\caption{The second type login response}
	\label{The second type login response}
\end{table}
Proof in \ref*{The second type login response} generation: $ md5(password)||48 spaces $
The user could be AuthToken or the User/UniqueNick (with the extra PartnerID).
server challenge that we received before.
the client challenge that was generated before.

\subsection{SDK Revision}


	\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[5]{GPCM}{GPCM}{}
		\begin{call}
			{Client}{Login}{GPCM}{Success}
		\end{call}
		\begin{callself}
			{GPCM}{Check SDK version}{}
			\mess{GPCM}{Send buddy message}{Client}
			\mess{GPCM}{Send buddy revoke}{Client}
			\mess{GPCM}{Send buddy request}{Client}
			\mess{GPCM}{Send buddy status info/buddy status}{Client}
			\mess{GPCM}{Send buddy list}{Client}
			\mess{GPCM}{Send block list}{Client}
		\end{callself}

		
	\end{sequencediagram}
	\caption{SDK Revision process}
\label{SDK Revision process}
\end{figure}

	


	When a player finished login, GPCM will check his sdkrevision, sdkrevision is an addition of each sdkrevision number. Every addition of sdkrevision number will make GPCM act differently.
\begin{mybox}
	\begin{itemize}
		\item Extended message support
		\begin{itemize}
			\item{1} GPI\_NEW\_AUTH\_NOTIFICATION = 1
			\item{2} GPI\_NEW\_REVOKE\_NOTIFICATION = 2
		\end{itemize}
		
		\item New Status Info support
		\begin{itemize}
			\item{4} define GPI\_NEW\_STATUS\_NOTIFICATION = 4
		\end{itemize}
		
		\item Buddy List + Block List retrieval on login
		\begin{itemize}
			\item{8} GPI\_NEW\_LIST\_RETRIEVAL\_ON\_LOGIN = 8
		\end{itemize}
	\item Remote Auth logins now return namespaceid/partnerid on login
	\begin{itemize}
		\item{16} GPI\_REMOTEAUTH\_IDS\_NOTIFICATION = 16
	\end{itemize}

	\item New CD Key registration style as opposed to using product ids
	\begin{itemize}
		\item{32}  GPI\_NEW\_CDKEY\_REGISTRATION = 32
	\end{itemize}

	\end{itemize}
\end{mybox}

For now, we know the sdkrevision number of GameSpy SDK test and Crysis2.


\section{GPI Buddy Module}
\subsection{Buddy Message}
The Buddy Message is a method to transmit message, buddy add request, game invite, friend revoke(friend deletion), buddy status(online status etc.).
\begin{figure}[H]
	\centering
	\scalebox{0.7}{
		\begin{tikzpicture}
		\node[block] (a) {Buddy Message}; 
		

		\node[block, right= of a](Request) {Request};
		\node[block, above= of Request] (Message) {Message};
		\node[block, above= of Message](UTM) {UTM};
		
		
		\node[block, below= of Request](Status) {Status};
		\node[block, below= of Status](Auth) {Auth};
		

		\node[block, left= of a](Invite) {Invite};
		\node[block,above= of Invite](Revoke) {Revoke};
		\node[block,below= of Invite](Ping) {Ping};
		\node[block,below= of Ping](Pong) {Pong};
		
		\draw[line] (a.west)--(Invite);
		\draw[line] (a.east)|-(Request);
		
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Revoke);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Ping);
		\draw[line] (a.west)--+(-0.5,-0.0)|-(Pong);
		
		\draw[line] (a.east)--+(+0.5,-0.0)|-(UTM);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Message);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Status);
		\draw[line] (a.east)--+(+0.5,-0.0)|-(Auth);
		\end{tikzpicture}
	}
	\caption{Buddy message module}
	\label{Buddy message module}
\end{figure}
When a Buddy Message received by a client, the client will determine Buddy Message type according to Table~\ref{Buddy Message Definition}.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Definition}&\textbf{Value} \\ 
		\hline 
 GPI\_BM\_MESSAGE&            1\\\hline
 GPI\_BM\_REQUEST     &               2\\\hline
 GPI\_BM\_REPLY        &            3  \\\hline
 GPI\_BM\_AUTH        &             4\\\hline
 GPI\_BM\_UTM            &            5\\\hline
 GPI\_BM\_REVOKE      &               6 \\\hline
 GPI\_BM\_STATUS       &          100			\\\hline			
 GPI\_BM\_INVITE           &       101\\\hline
 GPI\_BM\_PING             &      102\\\hline
 GPI\_BM\_PONG           &          103\\\hline
 GPI\_BM\_KEYS\_REQUEST        &    104\\\hline
 GPI\_BM\_KEYS\_REPLY            &   105\\\hline
 GPI\_BM\_FILE\_SEND\_REQUEST   &  200\\\hline
 GPI\_BM\_FILE\_SEND\_REPLY      &   201\\\hline
 GPI\_BM\_FILE\_BEGIN       &      202\\\hline
 GPI\_BM\_FILE\_END             &   203\\\hline
 GPI\_BM\_FILE\_DATA             & 204\\\hline
 GPI\_BM\_FILE\_SKIP          &      205\\\hline
 GPI\_BM\_FILE\_TRANSFER\_THROTTLE   &206\\\hline
 GPI\_BM\_FILE\_TRANSFER\_CANCEL&     207\\\hline
 GPI\_BM\_FILE\_TRANSFER\_KEEPALIVE &208\\\hline
	\end{tabular} 
	\caption{Buddy Message Definition}
	\label{Buddy Message Definition}
\end{table}
Because Client1 and Client2 are in NAT network, so they can not connect each other using p2p, so GPCM will forward message for them. The forward diagram shows in Figure~\ref{Buddy message diagram}

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client1}{Client1}{}
		\newinst[3]{GPCM}{GPCM}{}
		\newinst[3]{Client2}{Client2}{}
		\begin{messcall}
			{Client1}{Send buddy message}{GPCM}
			\begin{messcall}
				{GPCM}{Forward buddy message}{Client2}
			\end{messcall}
		\end{messcall}
		
	\end{sequencediagram}
	\caption{Buddy message diagram}
\label{Buddy message diagram}
\end{figure}

All Buddy Message from Client will have same prefix which we show in \ref{Client buddy message prefix}
\ClientRequest

\begin{mybox}[label=Client buddy message prefix]
	\tbs bm\tbs <buddy message type>\tbs sesskey\tbs <session key>\\
	\tbs t\tbs<profile id>\tbs date\tbs<date>\tbs$ \cdots $\tbs final\tbs
\end{mybox}



\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bm & Indicate the buddy message command, please see \ref{Buddy Message Definition}&Uint \\ 		
		\hline 
		t & Profileid of the receiver&Uint \\
		\hline 
		sesskey&The session key of the sender client&Uint\\	\hline
		msg& The message contents& String\\\hline 
	\end{tabular} 
	\caption{Client buddy message command in prefix}
	\label{Client buddy message command in prefix}
\end{table}



All Buddy Message from GPCM will have same prefix which we show in \ref{Buddy message prefix}. The contents in $ \cdots $ is different from each Buddy Message Type.
\ServerResponse

\begin{mybox}[label=Buddy message prefix]
	\tbs bm\tbs <buddy message type>\tbs f\tbs<profile id>\tbs date\tbs<date>\tbs$ \cdots $\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bm & Indicate the buddy message command, please see \ref{Buddy Message Definition}&Uint \\ 		
		\hline 
		f & Profileid of the sender&Uint \\
		\hline 
		date&The date that this message is sent, this value can be empty, possible format should be $ xxxxxxxx $ e.g. $ 20200201 $&Uint\\	\hline
		msg& The message contents& String\\\hline 
	\end{tabular} 
	\caption{Buddy message command in prefix}
	\label{Buddy message command in prefix}
\end{table}

Next following subsections we introduce message contents,  the message content will use in both client buddy message and server buddy message. We only write the message contents after \tbs msg\tbs.
\subsubsection{Message}
This is a general message

\begin{mybox}
	\tbs msg\tbs<message content>\tbs final\tbs
\end{mybox}


\subsubsection{UTM}

\begin{mybox}
	\tbs msg\tbs<UTM message>\tbs final\tbs
\end{mybox}


\subsubsection{Request}
This is a add friend request.
\ServerResponse

\begin{mybox}
	\tbs msg\tbs|signed|<signature>\tbs final\tbs
\end{mybox}

\subsubsection{Auth}
Auth method is a add friend function.
Auth method do not have contents after $ \backslash date \backslash $.
\subsubsection{Revoke}
Revoke method is called when a client1 deleted a client2 in his friend list. When deletion is finished in client1, client1 will send revoke message to GPCM, GPCM will forward this message to client2, then client2 will delete player1 in his friend list.
Revoke method do not have contents after $ \backslash date \backslash $.
\subsubsection{Status}\label{Buddy Status}
This is an old method for game to get status information. buddy status \ref{Buddy Status} and buddy status info \ref{Buddy Status Info} can not be used at same time. Buddy status method is a part of Buddy Message module, old game send buddy status through a buddy message.
\ServerResponse

\begin{mybox}
	\tbs msg\tbs|s|<status code>|ss|<status string>|ls|<location string>\\
	|ip|<ip address>|p|<port>|qm|<quiet mode flag>\tbs final\tbs
\end{mybox}


\subsubsection{Invite}
Invite method is used to invite a player to a game which is currently playing by another player.

\ClientRequest

\begin{mybox}
	\tbs msg\tbs|p|<product id>|l|<location string>\tbs final\tbs
\end{mybox}



\subsubsection{PING}
Ping method maybe is used to check the ping to other player. 

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client1}{Client1}{}
		\newinst[3]{GPCM}{GPCM}{}
		\newinst[3]{Client2}{Client2}{}
		\begin{call}
			{Client1}{Send Ping request}{GPCM}{Forward pong response}
			\begin{call}
				{GPCM}{Forward ping request}{Client2}{Send pong response}
			\end{call}
		\end{call}
		
	\end{sequencediagram}
	\caption{PING and PONG diagram}
\label{PING and PONG diagram}
\end{figure}

\ClientRequest

\begin{mybox}
	\tbs msg\tbs\tbs final\tbs
\end{mybox}

\subsubsection{PONG}

\ServerResponse

\begin{mybox}
	\tbs msg\tbs 1\tbs final\tbs
\end{mybox}

\subsection{Buddy Status Info}\label{Buddy Status Info}
This is a new method used in new game. \ref{Buddy Status} is an old method used in old game. Currently we can not tell you which game use new method and which use old method.


\ServerResponse

\begin{mybox}[label=Buddy status info string]
	\tbs bsi\tbs\tbs state\tbs <buddy status>\tbs profile\tbs<profileid>\tbs bip\tbs<buddy ip>\\
	\tbs bport\tbs<buddy port>\tbs hostip\tbs <host ip>\tbs hprivip\tbs<host private ip>\\
	\tbs qport\tbs<query port>\tbs hport\tbs<host port>\tbs sessflags\tbs<session flags>\\
	\tbs rstatus\tbs<rich status>\tbs gameType\tbs<game type>\tbs gameVnt\tbs<game variant>\tbs gameMn\tbs<game map name>\tbs product\tbs<productid>\\
	\tbs qmodeflags\tbs<quiet mode flags>\tbs final\tbs
\end{mybox}

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline 
		\textbf{Keys}& \textbf{Description}&\textbf{Type}  \\ 
		\hline 
		bsi & buddy status info command & \\ 		
		\hline 
		state & Buddy status state&Enum \\
		\hline 
		profileid&The profileID &Uint\\	\hline 
		bip& Buddy ip &String\\	\hline 
		bport&Buddy port&Uint\\\hline
		hostip& Host ip&String\\\hline
		hprivip&Host private ip&String\\\hline
		qport&Query port&Uint\\\hline
		hport&Host port&Uint\\\hline
		sessflags&Session flag&Uint\\\hline
		rstatus&Rich status ?&String\\\hline
		gameType&Game type&String\\\hline
		gameVnt&Game variant&String\\\hline
		gameMn&Game map name&String\\\hline
		product&Productid&uint\\\hline
		qmodeflags&Quiet mode flag&Enum\\\hline
	\end{tabular} 
	\caption{Buddy status info keys}
	\label{Buddy status info keys}
\end{table}

\subsection{Buddy List}
Buddy list is a list which contains your friends.
GPCM server will send buddy list when a client is logged in. Process is showing in Fig~\ref{Buddy List} and the response is showing in \ref{Buddy list string}.

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[5]{GPCM}{GPCM}{}

		\mess{GPCM}{Send buddy list}{Client}

	\end{sequencediagram}
	\caption{Buddy List}
	\label{Buddy List}
\end{figure}

\ServerResponse

\begin{mybox}
	\label{Buddy list string}
	\tbs bdy\tbs<number of profileid>\tbs list\tbs<profileid 1>,
	\\<profileid 2>,$ \cdots $,<profileid n>\tbs final\tbs
\end{mybox}


\subsection{Block List}
Block list is an list which contain the players you do not like.
GPCM server will send block list when a client is logged in. Process is showing in Fig~\ref{Block List} and the response is showing in \ref{Block list string}.

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[5]{GPCM}{GPCM}{}
		
		\mess{GPCM}{Send block list}{Client}
		
	\end{sequencediagram}
	\caption{Block List}
	\label{Block List}
\end{figure}

\ServerResponse

\begin{mybox}[label=Block list string]
\tbs blk\tbs <number of profile id>\tbs list\tbs<profileid 1>,<profileid 2>,$ \cdots $,\\<profileid n>\tbs final\tbs
\end{mybox}

\subsection{Add Buddy}
When a client want to add another client into his buddy list. He will send the following request to GPCM.

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client1}{Client1}{}
		\newinst[3]{GPCM}{GPCM}{}
		\newinst[4]{Client2}{Client2}{}
		\begin{messcall}
			{Client1}{Send addbuddy request}{GPCM}
			\begin{messcall}
				{GPCM}{Translate addbuddy to bm request}{Client2}
			\end{messcall}
		\end{messcall}
		
	\end{sequencediagram}
	\caption{Add friend diagram}
\label{Add friend diagram}
\end{figure}

\ClientRequest

\begin{mybox}
	\tbs addbuddy\tbs\tbs sesskey\tbs<session key>\tbs newprofileid\tbs<profile id>\\
	\tbs reason\tbs<add friend reason>\tbs final\tbs
\end{mybox}

\subsection{Delete Buddy}
When a client want to delete a friend in his buddy list. He will send the following request to GPCM.
\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client1}{Client1}{}
		\newinst[3]{GPCM}{GPCM}{}
		\newinst[4]{Client2}{Client2}{}
		\begin{messcall}
			{Client1}{Send delbuddy request}{GPCM}
			\begin{messcall}
				{GPCM}{Translate delbuddy to bm revoke}{Client2}
			\end{messcall}
		\end{messcall}
		
	\end{sequencediagram}
	\caption{Delete friend diagram}
	\label{Delete friend diagram}
\end{figure}

\ClientRequest

\begin{mybox}
	\tbs delbuddy\tbs\tbs sesskey\tbs <session key>\tbs delprofileid\tbs <profile id>\tbs final\tbs
\end{mybox}

\subsection{Add Block}

\ClientRequest
\begin{mybox}
	\tbs addblock\tbs\tbs sesskey\tbs <session key>\tbs profileid\tbs <profile id>\tbs final\tbs
\end{mybox}



\section{GPI Info Module}
\subsection{Profile}
\subsubsection{Get Profile Information}
Find a user's profile information. signature string in response is used in adding someone as your friend through buddy message.
\ClientRequest

\begin{mybox}
	\tbs getprofile\tbs\tbs sesskey\tbs <session key>
	\tbs profileid\tbs <profile id>\\\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs pi\tbs\tbs profileid\tbs <profile id>\tbs nick\tbs <nick name>\\\tbs uniquenick\tbs <uniquenick>\tbs email\tbs<email>\tbs firstname\tbs<first name>\\
	\tbs lastname\tbs <last name>\tbs icquin\tbs<icquin>\\
	\tbs homepage\tbs<home page URL>\tbs zipcode\tbs<zip code>\\
	\tbs countrycode\tbs<country code>\tbs lon\tbs <longitude>\tbs lat\tbs<latitude>\\
	\tbs loc\tbs<location>\tbs birthday\tbs<birthday>\tbs sex\tbs<gender>\\
	\tbs pmask\tbs<public mask>\tbs aim\tbs<aim name>\tbs pic\tbs <picture>\\
	\tbs occ\tbs<occupation id>\tbs ind\tbs<industry id>\tbs inc\tbs<income id>\\
	\tbs mar\tbs<married id>\tbs chc\tbs<child count number>\tbs i1\tbs<interest 1>\\
	\tbs  o1\tbs<ownership 1>\tbs conn\tbs<connection type id>\\
	\tbs sig\tbs<peer to peer signature>\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}

Keys in profile module:
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Key}&\textbf{Description} \\ 
		\hline 
		cpubrandid&            cpu barand id\\\hline
		cpuspeed& cpu speed\\\hline
		memory&memory\\\hline
		videocard1ram& GPU memory size\\\hline
		videocard2ram& GPU memory size\\\hline
		connectionid&connection id\\\hline
		connectionspeed&connection speed\\\hline
		hasnetwork& unknow\\\hline
		passwordenc& encrypted password\\\hline
	\end{tabular} 
	\caption{Other keys in profile}
	\label{Other keys in profile}
\end{table}

\subsubsection{Update Profile Information}

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[3]{GPCM}{GPCM}{}
	\mess {Client}{Update profile request}{GPCM}
	\end{sequencediagram}
	\caption{Update profile diagram}
	\label{Update profile diagram}
\end{figure}


\ClientRequest

\begin{mybox}[label = update profile request]
	\tbs updatepro\tbs\tbs sesskey\tbs<session key>\tbs $\star$\tbs partnerid\tbs<partner id>\tbs final\tbs
\end{mybox}
The $\star$ in \ref{update profile request} is the profile information key and value pairs such as\textbf{ \tbs nick\tbs<nick name>\tbs}, etc.
\subsubsection{Update User Information}

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[5]{GPCM}{GPCM}{}
		\mess {Client}{Update user information request}{GPCM}
	\end{sequencediagram}
	\caption{Update user information diagram}
	\label{Update user information diagram}
\end{figure}


\ClientRequest
The $\star$ in \ref{update user information request} is the profile information key and value pairs such as \textbf{\tbs passwordenc\tbs<encrypted password>\tbs}, etc.
\begin{mybox}[label = update user request]
	\tbs updateui\tbs\tbs sesskey\tbs<session key>\tbs $\star$\tbs final\tbs
\end{mybox}



\subsection{GPI Profile Module}

\subsubsection{Create New Profile}
Create a new profile with nick name.
\ClientRequest

\begin{mybox}
	\tbs newprofile\tbs\tbs sesskey\tbs <session key>\tbs nick\tbs <nick name>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\subsubsection{Replace Existed Profile}
Replace nick name in a profile with a new nick name.
\ClientRequest

\begin{mybox}
\tbs newprofile\tbs\tbs sesskey\tbs <session key>\tbs nick\tbs <old nick name>\tbs replace\tbs 1\\\tbs oldnick\tbs<nick name>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

\subsubsection{Delete Profile}
\ClientRequest

\begin{mybox}
	\tbs delprofile\tbs\tbs sesskey\tbs<session key>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs dpr\tbs final\tbs
\end{mybox}



\subsection{GPI Unique Module}

\subsubsection{Register Unique Nick}
This method will register a new unique nick. There are two request \ref{register uniquenick1} and \ref{register uniquenick2}. The first one is only register unique nick, and the second one is register unique nick with cd key.
\ClientRequest
\begin{mybox}[label=register uniquenick1]
	\tbs registernick\tbs\tbs sesskey\tbs<session key>\tbs uniquenick\tbs<unique nick>\\\tbs partnerid\tbs<partner id>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
\begin{mybox}[label=register uniquenick2]
	\tbs registernick\tbs\tbs sesskey\tbs<session key>\tbs uniquenick\tbs<unique nick>\\\tbs cdkey\tbs<cd key>\tbs partnerid\tbs<partner id>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}

\ServerResponse
\begin{mybox}
	\tbs rn\tbs final\tbs
\end{mybox}


\subsubsection{Register CD Key}
\ClientRequest
\begin{mybox}
	\tbs registercdkey\tbs\tbs sesskey\tbs<session key>\tbs cdkeyenc\tbs<cd key enc string>\tbs id\tbs <operation id>\tbs final\tbs
\end{mybox}
\ServerResponse
\begin{mybox}
	\tbs rc\tbs final\tbs
\end{mybox}
\subsection{GPI Peer Module}
\subsection{GPI Transfer Module}



\chapter{GameSpy Presence Search Player}
GPSP server provides search function for client.\\
Table \ref{IP and Ports for GameSpy Presence Servers} are the GPSP IP and Ports that client/game connect to.


\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[4]{GPSP}{GPSP}{}
		
		\begin{call}
			{Client}{Send client search request}{GPSP}{Send search result}
		\end{call}
	
	\end{sequencediagram}
		\caption{GPSP diagram}
	\label{GPSP diagram}
\end{figure}

\section{Search Profile}
\ClientRequest 

\begin{mybox}
	\tbs search\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs <profile id>\tbs $\star$\\\tbs namespaceid\tbs<namespace id>\tbs partnerid\tbs<partner id>\\\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}

Symbol $\star$ contains client detail, we list client detail as follows.
\begin{mybox}
	\tbs nick\tbs<nick name>\tbs uniquenick\tbs <unique nick>\tbs email\tbs<email>\\\tbs firstname\tbs<first name>\tbs lastname\tbs<last name>\tbs icquin\tbs <icq uin>\\\tbs skip\tbs<skip>
\end{mybox}


\ServerResponse

\begin{mybox}[label = search user response]
	\tbs bsr\tbs\textbf{<profile 1>}\tbs bsr\tbs\textbf{<profile 2>}\tbs bsr\tbs $\cdots$\tbs \textbf{<profile n>}\\
	\tbs bsrdone\tbs\tbs more\tbs<number of rest profiles>\tbs final\tbs
\end{mybox}
The value in \textbf{<profile i>} is showing below \ref{content after bsr}.
\begin{mybox}[label = content after bsr]
<profileid>\tbs nick\tbs<nick>\tbs uniquenick\tbs<unique nick>\\\tbs namepaceid\tbs <namespace id>\tbs firstname\tbs<first name>\\\tbs lastname\tbs<last name>\tbs email\tbs<email>
\end{mybox}
\subsection{Seach Profile With Unique Nick}
\ClientRequest
\begin{mybox}
	\tbs searchunique\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs<profile id>\\\tbs uniquenick\tbs<unique nick>\tbs namespaces\tbs<namespace id 1,\\ namespace id 2, ..., namespace id n>\tbs final\tbs
\end{mybox}
\ServerResponse
The response from server is the same as \ref{search user response}.
\subsection{Search User Is Valid}
\ClientRequest

\begin{mybox}
	\tbs valid\tbs\tbs email\tbs<email>\tbs partnerid\tbs<partner id>\tbs final\tbs
\end{mybox}

\ServerResponse

Number 0 represents false, 1 represents true.
\begin{mybox}
	\tbs vr\tbs <valid code: 0 or 1>\tbs final \tbs
\end{mybox}

\subsection{Search Nick}
This method is used to search profile with nick name and email.
\ClientRequest

\begin{mybox}
	\tbs nicks\tbs\tbs email\tbs <email>\tbs passenc\tbs<encrypted password>\\\tbs namespaceid\tbs <namespace id>\tbs partnerid\tbs<partner id>\\\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}
	\tbs nr\tbs\tbs nick\tbs<data 1>\tbs<data 2>\tbs $\cdots$\tbs <data n> \tbs ndone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} shows below.
\begin{mybox}
	 <nick name>\tbs uniquenick \tbs<unique nick>
\end{mybox}

\subsection{Search Player}

\ClientRequest

\begin{mybox}
	\tbs pmatch\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs<profile id>\\\tbs productid\tbs <product id>\tbs gamename\tbs <game name>\tbs final\tbs
\end{mybox}

\ServerResponse
\begin{mybox}
	\tbs psr\tbs <data 1>\tbs psr\tbs<data 2>\tbs $\cdots$\tbs psr\tbs <data n>\tbs psrdone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} shows below.
\begin{mybox}
	<profile id>\tbs status\tbs<status string>\tbs nick\tbs<nick name>\\\tbs statuscode\tbs<status code>
\end{mybox}


\subsection{Search Check}
This method is used to check whether user exist.
\ClientRequest

\begin{mybox}
	\tbs check\tbs\tbs nick\tbs <nick name>\tbs email\tbs<email>\tbs partnerid\tbs <partner id>\\\tbs passenc\tbs<encrypted password>\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}

\ServerResponse
The error code in \ref{search check response} shows in .
\begin{mybox}[label = search check response]
	\tbs cur\tbs<check error code>\tbs pid\tbs <profile id>\tbs final\tbs
\end{mybox}

\subsection{User Creation}
This commmand \ref{Create user command} is used to create a user in GameSpy.
\ClientRequest

\begin{mybox}[label = Create user command]
\tbs newuser\tbs email \tbs <email>\tbs nick\tbs < nick name> \\
\tbs passwordenc\tbs <password enc>\tbs productid\tbs <product id>\\\tbs uniquenick\tbs <unique nick>
\tbs cdkeyenc\tbs <cdkeyenc>\\\tbs partnerid\tbs <partnerid>\tbs gamename\tbs <gamename>\tbs final\tbs
\end{mybox}

\ServerResponse
The newuser error code shows in .
\begin{mybox}
	\tbs nur\tbs<newuser error code>\tbs pid\tbs <profile id>\tbs final\tbs
\end{mybox}

\subsection{Search Others Buddy}
\ClientRequest

\begin{mybox}
	\tbs others\tbs\tbs sesskey\tbs<session key>\tbs profileid\tbs<profile id>\\\tbs namespaceid\tbs <namespace id>\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}
\ServerResponse
GPSP should try to find the information, if some account do not have unique nick then do not add \tbs uniquenick\tbs<unique nick>\tbs to response string.
\begin{mybox}
\tbs others\tbs\tbs o\tbs<data 1>\tbs o\tbs <data 2>\tbs $\cdots$\tbs <data n>\tbs odone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} is listed as follows.
\begin{mybox}
	<profile id>\tbs nick\tbs <nick name>\tbs uniquenick\tbs<unique nick>\\\tbs first\tbs<first name>\tbs last\tbs <last name>\tbs email\tbs<email>
\end{mybox}


\subsection{Search Others Buddy List}
Client send request to GPSP asking for the buddy's profiles with buddy profile id.
\ClientRequest

\begin{mybox}
	\tbs otherslist\tbs\tbs sesskey\tbs <session key>\tbs profileid\tbs<profile id>\\
	\tbs numopids\tbs<number of recieved buddy profiles>\\
	\tbs opids\tbs <profile id 1>|<profile id 2>|$\cdots$|<profile id 3>\\
	\tbs namespaceid\tbs <namespace id>\tbs gamename\tbs <game name>\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
	\tbs otherslist\tbs\tbs o\tbs<data 1>\tbs o\tbs<data 2>\tbs $\cdots$\tbs <data n>\tbs odone\tbs final\tbs
\end{mybox}
The content in \textbf{<data i>} is listed as follows.
\begin{mybox}
	<profile id>\tbs uniquenick\tbs <unique nick>
\end{mybox}



\subsection{Search Suggest Unique}

Client search suggest nick name on GPSP.

\ClientRequest
\begin{mybox}
	\tbs uniquesearch\tbs\tbs preferrednick\tbs<unique nick name>\\
	\tbs namespaceid\tbs<namespace id>\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}
\ServerResponse
\begin{mybox}
	\tbs us\tbs<number of suggest nick>\tbs nick\tbs <nick name1>\\
	\tbs nick\tbs<nick name2>\tbs $\cdots$\tbs nick\tbs <nick name n>\tbs usdone\tbs final\tbs
\end{mybox}


\subsection{Valid Email}
\ClientRequest
\begin{mybox}
	\tbs valid\tbs\tbs email\tbs<email account>\tbs partnerid\tbs <partner id>\\
	\tbs gamename\tbs<game name>\tbs final\tbs
\end{mybox}

\ServerResponse
\begin{mybox}
	\tbs vr\tbs<valid value>\tbs final\tbs
\end{mybox}



\part{Transport}






\part{NAT Negotation}

\chapter{Introduction}
The GameSpy NAT Negotiation SDK interacts with GameSpy's NAT Negotiation server to allow hosting of multiplayer games by users behind NAT and firewall devices. Typically, a user behind a NAT or firewall device cannot host multiplayer games because the device will block incoming connections from outside users. GameSpy's NAT Negotiation technology allows two users, one or both of whom are behind a NAT device, to open a clear UDP channel directly between the users.
GameSpy's NAT Negotiation technology uses a method known as "Port Guessing" to attempt to discern future port mapping information for two users based on their connections to the NAT Negotiation server. Once this mapping information is determined, the server exchanges the information with the users, and they connect to each other directly (note: the term "connect" in this document is understood to mean the establishment a clear, two-way channel between the users, since UDP is in reality a connection-less protocol).

Note that the NAT Negotiation SDK does not make any distinction between the "client" who is connecting to a "server" (or "host"), however this document will use those terms for clarity, and because the other SDKs involved do make that distinction.

The NAT Negotiation SDK itself is very simple - two users who want to be connected to each other have a shared "cookie" value that the NAT Negotiation server uses to match the users up. 

The NAT Negotiation SDK has no limit to the number of users that can be connected together, but each channel between two users must be independently established.

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		
		\newthread{Client1}{:Client1}{}
		\newinst[4]{NN1}{:NatNeg1}{}
		\newinst{NN2}{:NatNeg2}{}			\newinst{NN3}{:NatNeg3}{}
		
		\begin{call}
			{Client1}{ErtPacket(NN1)}{NN1}{InitACK(NN1)}
		\end{call}
		\begin{call}
			{Client1}{ErtPacket(NN1)}{NN1}{InitACK(NN1)}
		\end{call}
\begin{call}
		{Client1}{ErtPacket(NN3)}{NN2}{InitACK(NN3)}
\end{call}

\begin{call}
{Client1}{AddressMappingPacket(NN1)}{NN1}{InitACK(NN1)}
\end{call}	

\begin{call}
{Client1}{AddressMappingPacket(NN1)}{NN1}{InitACK(NN1)}
\end{call}	

\begin{call}
{Client1}{AddressMappingPacket(NN2)}{NN2}{InitACK(NN2)}
\end{call}	

\begin{call}
{Client1}{AddressMappingPacket(NN3)}{NN3}{InitACK(NN3)}
\end{call}	

	\end{sequencediagram}
	\caption{Single client nat detection sequence}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{sequencediagram}

		\newthread{Client1}{:Client1}{}
		\newinst[4]{NN1}{:NatNeg1}{}
		\newinst{NN2}{:NatNeg2}{}			\newinst{NN3}{:NatNeg3}{}
		
		\begin{call}
			{Client1}{InitPacket(Port type = GP)}{NN1}{InitACK()}
		\end{call}
			\begin{call}
			{Client1}{InitPacket(Port type = NN1)}{NN1}{InitACK()}
		\end{call}
			\begin{call}
			{Client1}{InitPacket(Port type = NN2)}{NN2}{InitACK()}
		\end{call}
		\begin{call}
		{Client1}{InitPacket(Port type = NN3)}{NN3}{InitACK()}
	\end{call}

	\end{sequencediagram}
	\caption{Single client nat negotiation sequence}
\end{figure}
\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client1}{:Client1}{}
		\newinst[3]{NN}{:NatNeg}{}
		\newinst[3]{Client2}{:Client2}{}
		
		\begin{call}
			{Client1}{InitPacket(ClientIndex=0)}{NN}{InitACK()}
		\end{call}

	\begin{call}
		{Client2}{InitPacket(ClientIndex=1)}{NN}{InitACK()}
	\end{call}

		\begin{messcall}
	{NN}{ConnectPacket}{Client1}
	\begin{messcall}
		{NN}{ConnectPacket}{Client2}
	\end{messcall}
\end{messcall}

\begin{messcall}
	{Client1}{ConnectPingPacket}{Client2}
	\begin{messcall}
		{Client2}{ConnectPingPacket}{Client1}
	\end{messcall}
\end{messcall}


	\end{sequencediagram}
\caption{Nat negotiation sequence}
\end{figure}



\begin{figure}[H]
	\scalebox{0.7}{
		\begin{sequencediagram}
			\newthread{Client}{:Client}{}
			\newinst[4]{NN}{:NatNeg}{}
			\newinst[2]{SB}{:ServerBrowser}{}
			\newinst[2]{GS}{:GameServer}{}		
			\begin{call}
				{Client}{Natify packet()}{NN}{ERT response()}
			\end{call}
			\begin{call}
				{Client}{Address mapping test()}{NN}{Address mapping response()}
			\end{call}
			\begin{call}
				{Client}{Initialization packet()}{NN}{Initialization packet response()}
			\end{call}
			\begin{call}
				{Client}{Get server list()}{SB}{Get server list response()}
			\end{call}
			\begin{messcall}
				{Client}{NatNeg cookie packet()}{SB}
				\begin{messcall}
					{SB}{NatNeg connect packet()}{GS}
				\end{messcall}
			\end{messcall}
			\begin{call}
				{GS}{Nat negotiation()}{NN}{Nat negotiation()}
			\end{call}
			\begin{call}
				{Client}{Try connect()}{GS}{Try connect()}
			\end{call}
			
		\end{sequencediagram}
	}
	\caption{NatNeg general sequence diagram}
\end{figure}



\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		NATNEG&natneg1.gamespy.com&27901 (udp) \\ 
		\hline
				NATNEG&natneg3.gamespy.com&27901 (udp) \\ 
		\hline 
				NATNEG&natneg2.gamespy.com&27901 (udp) \\ 
		\hline 
	\end{tabular} 
	\caption{IP and Ports for NatNeg Servers}
	\label{IP and Ports for NatNeg Servers}
	
\end{table}


Nat Negotiation mechanism:
Because the ip address and other environment are changing from time to time, so when a client1 wants to connect
to client2, he dose not know any informations about client2, so he cannot connect to client2. using natneg it can ask client2 information on gamespy nat server and connect to client2.

Nat Negotiation SDK do the following things:
\begin{itemize}
	\item Clients connect to GameSpy NatNeg server
	\item Clients send the heart beat data that contain all information about himself to GameSpy NatNeg server
	\item GameSpy Nat server store clients information.
	\item when a client1 is try to connect to other client2:
	\begin{itemize}
		\item client1 send request to GameSpy NatNeg server
	\item GameSpy NatNeg server send the information about client2 to client1
		\item  client1 get the client2 information and connect.
	\end{itemize}
	

\end{itemize}




\section{NetNag Packet}

\begin{mybox}
	typedef struct \_NatNegPacket \\
	\{\\
	unsigned char magic[NATNEG\_MAGIC\_LEN];\\
	unsigned char version;\\
	unsigned char packettype;\\
	int cookie;	\\
	
	union\\
	\{\\
	InitPacket Init;\\
	ConnectPacket Connect;\\
	ReportPacket Report;\\
	\} Packet;\\
	
	\} NatNegPacket;
\end{mybox}

\subsection{Magic Data}
Every heart beat packet start with magic data.
\begin{mybox}
	Magic Data: 0xFD 0xFC 0x1E 0x66 0x6A 0xB2
\end{mybox}

\subsection{NatNeg Packet Type}
Client's heart beat contains NatNeg packet type which we list as follows.

\begin{table}[H]
	\centering
	\begin{tabular}{A}
		\hline
		\textbf{Packet type} &\textbf{Description}&\textbf{Value}\\\hline
		Init &Heart beat to let server know the existence of the client(client to server)& 0\\\hline
		ErtTest&External reachable test (client to server)&2\\\hline
		Connect&Directly send to another client try to connect with each others (client to client)&5\\\hline
		Connect Ack&Client already received the connect request and tried to connect to the other client (client to client)&6\\\hline
		Connect ping&Test the latency between each other (client to client)& 7\\\hline
		BackupTest&&8\\\hline
		Address check&Identify client's IP address mapping relations (client to server)& 10\\\hline
		Natify request&Identify NAT type (client to server)&12\\\hline
		Report &NAT negotiation result report (client to server)& 13\\\hline
	\end{tabular}
	\caption{NatNeg client request packet type}
	\label{NatNeg client request packet type}
\end{table}


\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Packet type} &\textbf{Description}&\textbf{Value}\\\hline
		InitAck&Init packet acknowledgment&1\\\hline
		ErtAck&External reach test acknowledgment&3\\\hline
		Backup Ack&Backup packet acknowledgment&9\\\hline
		Address reply&Address mapping relation reply&11\\\hline
		Report Ack&Report packet acknowledgment&15\\\hline
	\end{tabular}
	\caption{NatNeg server response packet type}
	\label{NatNeg server response packet type}
\end{table}


%Magic: 0xFD 0xFC 0x1E 0x66 0x6A 0xB2
%Version: 0x03
%
%Command 1: Natify Request (0x12)
%Cookie: htonl(777)
%
%Sets Packet Init. portType to 1 if Natneg server is natneg1, 2 if it's natneg2, 3 if it's natneg3
%
%Command 2: Address check (discover mapping)
%
%Sets portType to as the same as Command 1
%Cookie is htonl(0 for natneg1 (map1A), 1 for natneg2, 2 for natneg3, 3 for natneg1 second map (Map1B))


\subsection{Initial Packet}
\begin{mybox}
	typedef struct \_InitPacket\\
	\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char usegameport;\\
	unsigned int localip;\\
	unsigned short localport;\\
		char[] gamename;\\
	\} InitPacket;\\

\end{mybox}

\subsection{Report Packet}

\begin{mybox}
	\#define REPORTPACKET\_SIZE BASEPACKET\_SIZE + 61\\
	typedef struct \_ReportPacket\\
	\{\\
	unsigned char porttype;\\
	unsigned char clientindex;\\
	unsigned char negResult;\\
	NatType natType;\\
	NatMappingScheme natMappingScheme;\\
	char gamename[50];\\
	\} ReportPacket;\\
\end{mybox}



\subsection{Connect Packet}

\begin{mybox}
	\#define CONNECTPACKET\_SIZE BASEPACKET\_SIZE + 8\\
	typedef struct \_ConnectPacket\\
	\{\\
	unsigned int remoteIP;\\
	unsigned short remotePort;\\
	unsigned char gotyourdata;\\
	unsigned char finished;\\
	\} ConnectPacket;\\
\end{mybox}

\section{Nat Negotiation Process}

Natify --> AddressCheck --> Init --> Connect --> ConnectPing --> Report



\subsection{Nat Identification}

When client start, it sends 3 different Natify packet (NN1,NN2,NN3)to NatNeg server to discover it's reach-ability.

ERT stands for external reach test, which detect network environment. check your private ip and port whether equal to your public ip and port.
\subsection{Address Check}
Then client will send 4 address check packets to NatNeg server to discover network mapping. Each packet contains cookie defined before which are \{packet\_map1a, packet\_map1b, packet\_map2, packet\_map3\}.

\subsubsection{Initial NatNeg}

\ClientRequest
Client sends a initpacket which contains an extra information of gamename to NatNeg server.

\ServerResponse
Server changes the packet type of received initpacket to InitAck then send back this packet to sender.






\part{Peer to Peer communication}

\chapter{Peer to Query Report Server}
\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[3]{QR}{Query Report}{}

		\mess{Client}{Send state changed request}{QR}
		\begin{callself}
			{QR}{Update server state}{}
		\end{callself}
		
	\end{sequencediagram}
	\caption{Peer to query report diagram}
	\label{Peer to query report diagram}
\end{figure}


\chapter{Peer to Server Browser Server}
\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[3]{SB}{Server Browser}{}
		\newinst[2]{QR}{Query Report}{}
		\begin{callself}
			{Client}{Call peer module}{Call server browser module}
		\end{callself}
	\begin{call}
		{Client}{Search group list}{SB}{Send groups list}
		\begin{call}
			{SB}{Search groups list}{QR}{Send groups list}
		\end{call}
	\end{call}
		
	\end{sequencediagram}
	\caption{Peer to server browser diagram}
	\label{Peer to server browser diagram}
\end{figure}

\part{Patching \& Tracking}
\part{Query \& Reporting}
Query Report server is responsible for server available check and dedicated server information collection. Query Report server and Server Browser server communicate with each other, these two servers generally called master server. 

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		QR&*.master.gamespy.com&27900 (Udp) \\ 
		\hline 
	\end{tabular} 
	\caption{IP and Ports for Query Report Server}
	\label{IP and Ports for Query Report Server}
\end{table}

\chapter{Avaliable Check}
According to GameSpy SDK every game needs to check GameSpy back end server before using multiplayer. The contents in client request are shown below.
\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[3]{QR}{QR}{}
		\begin{call}
			{Client}{Available check()}{QR}{Response()}
		\end{call}
	
	\end{sequencediagram}
	\caption{The sequence of available check}
\end{figure}

\ClientRequest
\begin{mybox}
	PacketType:0x09\\
	GameName:<game name>\\
\end{mybox}

The response of available check is fixed with first 6 bytes, last byte is the status of the master server.

\begin{table}[H]
	\centering
	\begin{tabular}{|l|m{5cm}|c|}
		\hline
		\textbf{Status}&\textbf{Description}&\textbf{Value}\\\hline
		Available&the game's backend services are available&0\\\hline
		Unavailable& the game's backend services are unavailable&1\\\hline
		TemporarilyUnavailable&the game's backend services are temporarily unavailable&2\\\hline
	\end{tabular}
\caption{Available check server status}
\label{Available check server status}
\end{table}

\ServerResponse

\begin{mybox}
	0xfe, 0xfd, 0x09, 0x00, 0x00, 0x00, <server status \ref{Available check server status}>
\end{mybox}

\chapter{Game Server Information Report}
Query Report server collecting information about the player, server, team.
\section{General Information}
\begin{table}[H]
	\centering
	\begin{tabular}{|l|m{9cm}|}
		\hline
		\tbf{Data type}&\tbf{Description}\\\hline
		Server data&This is general information about the game in progress, for example - the map that is being played, the type of game, and any specific game settings that would be of interest to players before they joined.\\\hline
		Player data&This is information about a specific player that is in the current game, for example - the player's name, their current score, what team they are on, and the latency to the game server. 
		\\\hline
		Team data&This is information about a specific team in the current game, for example - the name of the team and the team score. If your game does not support team play you do not need to report any team information. 
		\\\hline
	\end{tabular}
\caption{The report data type }
\label{The report data type}
\end{table}
The format of the data in report data is key value pair. GameSpy gives several GameSpy defined keys that we list as follows and game can define their custom key to report.

\begin{table}[H]
	\centering
	\begin{tabular}{C}
		\hline
		\tbf{Key}&\tbf{Description}\\\hline
		hostname &a descriptive host-defined string (can include spaces) that identifies the server (e.g. "Joe's Game!") \\\hline
		gamever &a version specifier (e.g. 1.23) \\\hline
		hostport &the port that the game networking is running on and that the client should connect to. If the game shares a port with the Query and Reporting 2 SDK, you do not need to specify this. \\\hline
		mapname &the map name (either filename or descriptive name) \\\hline
		gametype &string which specifies the type of game, or the mod being played. \\\hline
		gamevariant &if the particular game type has multiple variants, you can report it using this key. \\\hline
		numplayers  &numeric string, number of players on the server \\\hline
		numteams &numeric string, number of teams on the server \\\hline
		maxplayers &numeric string, max number of players for this server \\\hline
		gamemode &string which specifies what is going on in the game at that time. see Table~\ref{Game mode detail} \\\hline
		teamplay &number which defines the type of teamplay in use, or 0 for no teamplay. Values > 0 are up to the developer \\\hline
		fraglimit &number of total kills or points before a level change or game restart \\\hline
		teamfraglimit &number of total kills or points for a team before a level change or game restart \\\hline
		timelimit &amount of total time before a level change or game restart occurs (generally in minutes) \\\hline
		timeelapsed &amount of time (in seconds) since the current level or game started 
		\\\hline
		roundtime &amount of time before a round ends (for round based games) \\\hline
		roundelapsed &amount of time (in seconds) that the current round has been in progress 
		\\\hline
		password &0 or not present if no password is required to join, 1 if password is required. Implementation of actual password protection is up to the game developer's network code. \\\hline
		
		groupid &
		(optional) If the server being hosted is part of a "group room" then it needs to report which groupid it is part of (as passed in on launch) \\\hline
		player\_ &
		a player name (may include spaces) \\\hline
		score\_ &
		numeric string that contains the score (kills/points) for a single player \\\hline
		skill\_ &
		a skill rating, if applicable, for a single player \\\hline
		ping\_ &
		the ping for a player (as measured between the player and the server) \\\hline
		team\_ &
		the team a player is on, either numeric or string \\\hline
		deaths\_ &
		number of deaths a player has had \\\hline
		pid\_ &
		The profileID number for a player (if logged in with the P\&M SDK) \\\hline
		team\_t &
		the name for a team \\\hline
		score\_t &
		the score for a team \\\hline
		
		
		
	\end{tabular}
\caption{Report data keys}
\label{Report data keys}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{C}
		\hline
		\tbf{Key}&\tbf{Description}\\\hline
		openwaiting&game has not yet started and players can join \\\hline
		closedwaiting& game has not yet started and players cannot join \\\hline
		closedplaying &game is in progress, no joining allowed \\\hline
		openplaying &game is in progress, players may still join \\\hline
		openstaging / closedstaging&
		Use to report that the game is in staging mode (should generally not be used directly - the Peer SDK handles this automatically). \\\hline
		exiting &server is shutting down \\\hline
	\end{tabular}
\caption{Game mode detail}
\label{Game mode detail}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\tbf{Packet type}&\tbf{Value}\\\hline
		Query & 0x00\\\hline
		Echo response & 0x05\\\hline
		Client Message & 0x06\\\hline
		Message ACK &0x07 \\\hline
		Keep alive & 0x08\\\hline
	\end{tabular}
\caption{Query report client packet}
\label{Query report client packet}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\tbf{Packet type}&\tbf{Value}\\\hline
		Pre-query ip verify&0x09\\\hline
		Challenge&0x01\\\hline
		Echo & 0x02 \\\hline
		AddError & 0x04\\\hline
		Keep alive & 0x08 \\\hline
	\end{tabular}
	\caption{Query report server packet}
	\label{Query report server packet}
\end{table}


\section{Pre-Query IP Verify Packet}
\begin{itemize}

	\item Server uses this packet to verify the IP of a client that connects to the server. 
	\item This is only done if the user enable  IP challenge. 
	\item Each new client has to verify them-self with a challenge.
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
			\newthread{QR}{QR}{}
			\newinst[6]{Client}{Client}{}
		\begin{call}
			{QR}{IP verify request(pre-query packet [\ref{Query report client packet}])}{Client}{IP verify response(query packet [\ref{Query report server packet}])}
		\end{call}
	\end{sequencediagram}
	\caption{The sequence of IP verify}
\end{figure}
This packet has limit length 200 bytes.
\ServerResponse
\begin{mybox}
	|Magic data(2 bytes)|Packet type (1 byte)|Instant key(4 bytes)|Server challenge (int)|
\end{mybox}

\section{Query Packet}
After receiving the pre-query ip verify request from server, client will compute the challenge response and send to server. 

\section{Heart Beat Packet}
Heat beat packet is used to report the information about server, player and team.
We guess when QR server received  a heartbeat packet, it will generate an challenge and send to game server. after received challenge game server will compute response and send to QR server to verify. If game server response is valid then QR server will add this server to server list.

Custom keys are used to define custom data to report, for example if the user is playing with a Windows or Macintosh.

There could be two types of custom keys:
Player keys (they end with \_):
Custom player information
Team keys (they end with \_t):
Custom team (or brigade) information
Server keys (they don't end with anything):
Custom server information

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[3]{QR}{QR}{}
		\begin{call}
			{Client}{Hear beat report()}{QR}{Challenge()}
		\end{call}
		\begin{call}
			{Client}{Challenge response()}{QR}{Echo packet()}
		\end{call}
		\begin{messcall}
			{Client}{Echo packet()}{QR}
		\end{messcall}
	\end{sequencediagram}
	\caption{The sequence of heart beat packet process}
\end{figure}


\ClientRequest
\begin{mybox}
	|Instant key (4 bytes) | \tbs0\tbs0 |Total number of server keys (1 byte) | Server keys (unknown bytes) | \tbs0\tbs0 | Total number of player keys (1 byte) | Player keys (unknown bytes) | \tbs0\tbs0 |Total number of team keys (1 byte) | Team key (unknown byte) |
\end{mybox}
\section{Challenge Packet}
When received the heart beat packet from client, Query Report server sends a challenge packet to verify the authenticity of the report client to prevent some illegal client.
\ServerResponse 
\begin{mybox}
	| Magic data | Packet type | Instant key | Challenge (5 bytes) | User IP (4 byte) | 4 bytes padding | User port (4 byte) |
\end{mybox} 

\section{Echo Packet}
We guess echo packet is used to detect the ping between server and Query Report server.

\section{AddError Packet}
This packet means address error, when query report server find client ip is not valid, server will send this packet to client.



%Query (0x00)
%This packet verify the IP of the client by checking if the random data
%it was sended before (With 0x09) is the same. If it isn't the server won't
%verify the client.
%

%
%
%

%

%
%Custom keys starts from 50 to 253
%
%
%IP: gamename.master.gamespy.com
%Port 27900
%Protocol: UDP
%

%
%The dedicated server have to send the heartbeat packet each 10 seconds in order to maintain his connection
%alive.
%
%The Instance key is a random 4 bytes array characters generated by the client when it tries
%to connect to the server
%
%The heartbeat communicates everything new it happends to the server, like someone connected or similar.
%\\
%Keep alive packet:
%A 5 bytes buffer composed by
%0x08 (The packet id)
%Instance key
%\\
%3 types of heartbeat packets
%Type 3: Challenge heartbeat
%Type 2: A server is shutting down
%Type 1: User requested a change in the game data
%Type 0: Normal heartbeat
%\\
%General heartbeat packet:
%
%0x03 (The Packet ID)
%Instance key
%\\
%A key represents the information of a data, much like a Dictionary (Similar to GPSP, but it uses $\backslash$0 rather than $\backslash\backslash$) 
%\\
%List of known keys:
%localipX (Where X is the number of local IP starting from 0): Local IP of the server
%localport: Query port binded by the server, where the Master Server can connect to
%natneg: If you can nat negotiate with the server (If you do, the keep alive packet will also be sended)
%statechanged: Integer (Type of heartbeat, see above)
%gamename: Name of the game
%\\
%If the server want to track the local clients public ip, also this two extra parameters will be sended:
%publicip: Public IP of the server
%publicport: Public port
%\\
%The custom keys are now added with their respective value
%Server, Player and Team
%\\
%
%NOTE: In the heartbeat, we are always querying the current known keys, so
%rather than being "customkey\_one\tbs0customkey\_one\_data\tbs0" it's just "customkey\_one\tbs0\tbs0"
%\\
%(Each key is delimited by \tbs0)
%\\
%B. Check queries (Process any new query)
%\\
%We receive some data from the server.
%\\
%CD-Key query:
%They start with 0x3B, nothing else is known
%See CD-KEY Reverse for more information
%\\
%Query Report 1 queries (compatibility):
%They start with $\backslash$
%\\




\chapter{The Process of CD key or Nat Negotiation authentication with Query Report}


\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[1]{QR}{QR}{}
		\newinst[4]{CDKey}{CD-Key}{}
		\newinst{NN}{NatNeg}{}
\begin{call}
	{Client}{Authentication}{QR}{Response}
	\begin{call}
		{QR}{Forward authentication request}{CDKey}{response}
	\end{call}
	\begin{call}
		{QR}{Forward authentication request}{NN}{Response}
	\end{call}
\end{call}
	\end{sequencediagram}
	\caption{The diagram of CD key or NatNeg server authentication with query report}
\end{figure}


\part{Server Browser}

\chapter{Overview}
The GameSpy Server Browsing SDK is a portable LAN and Internet server browser engine. It allows developers to quickly and easily add a list-based matchmaking interface to the game, with powerful features such as server-side filtering, sorting, country-filtering, and ping (latency) measurement.

\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[6]{SB}{Server Browser}{}
		\begin{call}
			{Client}{Server list request}{SB}{Has keys response}
		\end{call}		
		\mess {SB}{Servers full rule response}{Client}
	\begin{call}
	{Client}{Server rules request}{SB}{Has full rules response}
	\end{call}
	\begin{call}
		{Client}{Send message request(ask for new server)}{SB}{Push server message}
	\end{call}
	\begin{call}
		{Client}{Map loop request}{SB}{Map loop message}
	\end{call}
	\begin{call}
		{Client}{Player search request}{SB}{Player search message}
	\end{call}
	\begin{call}
		{SB}{Keep alive message}{Client}{Keep alive reply}
	\end{call}

	\mess{SB}{Delete server}{Client}
		
	\end{sequencediagram}
	\caption{Total process of server browser server}
\end{figure}

\chapter{Server List Retrieve}\label{Server list retrieve}
When a client want to see how many servers are online for playing it will do the following.
\begin{figure}[H]

	\begin{sequencediagram}
		\newthread{client}{Client}{}
		\newinst[3]{SB}{Server Browser}{}
		\newinst[2.7]{QR}{Query Report}
		\begin{call}
			{client}{Server list retrieve request}{SB}{Server list response}
			\begin{call}
				{SB}{Searching online game server}{QR}{Online server info}
			\end{call}
		\end{call}
		\end{sequencediagram}

	\end{figure}


{\color{red}Note}: The port in request and response should be check if it is little Indian, and according to the result we should do byte reverse on port. \\
NTS string means Null Terminated String which ends with \tbs0.
\ClientRequest
\begin{mybox}[label=Server browser client request]
Total length of the request (2 bytes) \\
 Protocol version (1 byte) \\
 List protocol version (1 byte)\\
 Encoding version (1 byte)\\
 Game version (4 bytes)\\
 Game name for development(i bytes)\\
 Game name for real application(i bytes)\\
 Challenge (8 bytes)\\
 Server filter(i bytes)\\
 Key field list(i bytes)\\
 Query option (4byte) \\
 Source IP (4 bytes) [optional]\\
 Max servers (4 bytes) [optional]
\end{mybox}
After query option there could be more bytes which is listed as follows.
If there has alternate source ip option the following should be added after query option.
If there has limit result count option the following should be added after query option.


\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|}
		\hline
		\tbf{Name} & \tbf{Value}\\\hline
		SERVER\_LIST\_REQUEST & 0\\\hline
		SERVER\_INFO\_REQUEST & 1 \\\hline
		 SEND\_MESSAGE\_REQUEST	&2\\\hline
		 KEEPALIVE\_REPLY	&		3\\\hline
		 MAPLOOP\_REQUEST		&	4\\\hline
		 PLAYERSEARCH\_REQUEST	&5\\\hline
	\end{tabular}
\caption{Server browser request}
\end{table}
\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|}
		\hline
		\tbf{Name}&\tbf{Value}\\\hline
		PUSH\_KEYS\_MESSAGE & 1 \\\hline
		PUSH\_SERVER\_MESSAGE & 2 \\\hline
		KEEPALIVE\_MESSAGE & 3 \\\hline
		DELETE\_SERVER\_MESSAGE & 4 \\\hline
		MAPLOOP\_MESSAGE & 5 \\\hline
		PLAYERSEARCH\_MESSAGE & 6 \\\hline
	\end{tabular}
	\caption{Server browser response}
\end{table}
The list protocol version=1 and Encoding version=3 in code \ref{Server browser client request}. We do not know if there is another protocol version exist only by looking at the GameSpy SDK. Server filter can select the server according to condition client send to server browser.
Filed list contains the keys that client need such as game name, game type, map name etc.

\begin{table}[H]
	\centering
	\begin{tabular}{|M{4.5cm}|M{5.3cm}|M{1cm}|}
		\hline
		\tbf{Update option name} &\tbf{Description} & \tbf{Value}\\\hline
		SEND\_FIELDS\_FOR\_ALL & Unknown & 1\\\hline
		NO\_SERVER\_LIST & Only sends servers info do not send keys values etc.&2\\\hline
		PUSH\_UPDATES & Updates server information in group list (used by peer)& 4\\\hline
		ALTERNATE\_SOURCE\_IP &&8\\\hline
		SEND\_GROUPS& Sends groups information (used by peer)&32\\\hline
		NO\_LIST\_CACHE& Unknown &64\\\hline
		LIMIT\_RESULT\_COUNT&Sends servers with a limit number&128\\\hline
	\end{tabular}
	\caption{Server browser server list update options}
\end{table}


\ServerResponse

\begin{mybox}[label=server list response]
Random byte (1 byte) $ \land $ 0xEC \\
Response Message Length $ \land $ xEA (1 byte)\\
Server Challenge (i bytes)\\
Client's public ip (4 bytes)\\
Standard query port (2 bytes)\\
Number of keys (1 byte)\\
Keys list $\rightarrow$ \ref{section key list}\\
Unique values list $\rightarrow$ \ref{section unique value list}\\
Servers info list  $\rightarrow$ \ref{section servers info list}

AdHoc data $\rightarrow$ \ref{section adhoc data}
\end{mybox}

\section{Keys List}\label{section key list}
The key list in above contains all keys that client required for. Each key is separate by \tbf{0x00} and the first byte of each key is the key type. There are 3 types we listed as follow.

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\tbf{Key type}&\tbf{Value}\\\hline
		Byte & 0 \\\hline
		Short & 1 \\\hline
		String & 2 \\\hline
	\end{tabular}
\caption{The key type enumerator}
\end{table}

\begin{mybox}[label=key list]
	Key-1 type (1 byte), Key-1 name (i bytes)\\
	Key-2 type (1 byte), Key-2 name (i bytes)\\
	$\cdots$ \\
	Key-n type (1 byte), Key-n name (i bytes)
\end{mybox}

\section{Unique Values List}\label{section unique value list}
There are 2 ways to parse the value:
\begin{itemize}
	\item Popular value: presents all string value inside unique value list, gives indexes in servers info list.
	\item Null terminate string: presents all string value inside server info list, sets the unique value number to 0.
\end{itemize}

Each unique value is separate by \tbf{0x00}.
\begin{mybox}[label=unique value list]
	Unique value1 (i bytes)\\
	 Unique value2 (i bytes)\\
	 $\cdots$\\
	 Unique value3 (i bytes)\\
\end{mybox}


\section{Servers Info List}\label{section servers info list}
Servers info list contains multiple information of servers, each server is separated by server flags\ref{Server flags in servers info list}, final server should end with \tbf{0x00FFFFFFFF}.



\begin{mybox}
	Server flag (1 byte)\\
	Server public ip (4 bytes)\\
	Private port (4 bytes) [optional]\\
	Private IP (4 bytes) [optional]\\
	ICMP IP (4 bytes) [optional]\\
	String index or NTS string
\end{mybox}

If you use popular value to parse values there should be string index which starts with 0. Each index represents the value index.
\begin{mybox}
	0 | 1 | 2 | $ \cdots $ | n
\end{mybox}
If you use NTS string you should parse value in this way:
\begin{mybox}
	0xFF | value | 0x00
\end{mybox}

The game server flag in \ref{server list response} is listed as follows.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|}
		\hline
			\tbf{Flag name}&\tbf{Value}	\\\hline
			UNSOLICITED\_UDP\_FLAG &1 \\\hline
			PRIVATE\_IP\_FLAG &2 \\\hline
			CONNECT\_NEGOTIATE\_FLAG  &4\\\hline	
			ICMP\_IP\_FLAG & 8\\\hline
			NONSTANDARD\_PORT\_FLAG & 16\\\hline
			NONSTANDARD\_PRIVATE\_PORT\_FLAG &32 \\\hline
			HAS\_KEYS\_FLAG & 64\\\hline
			HAS\_FULL\_RULES\_FLAG &128 \\\hline 
	\end{tabular}
\caption{Server flags in servers info list}
\label{Server flags in servers info list}
\end{table}

\section{AdHoc Data}\label{section adhoc data}
AdHoc data is used to help peer module setup game service.\\
If game want to use this function, client should require servers list \ref{Server list retrieve}  then the crypt header will be initialized which can be used to encrypt further communication.\\
AdHoc data contains the following types of command.

\subsection{Push Keys List}

\ServerResponse
\begin{mybox}
	Number of keys (1 byte)\\
	Keys list with key type (i bytes) [NTS string]
\end{mybox}

\subsection{Push Server}
Search a server's keys and full rules from server browser.
\ServerResponse
\begin{mybox}
	Server flag (1 byte)~\ref{Server flags in servers info list}\\
	Server public IP (4 bytes)\\
	Server public port (2 bytes)
\end{mybox}
\subsection{Keep Alive}


\subsection{Delete Server}
Delete a specific server in servers list.
\ServerResponse
\begin{mybox}
	Server public IP (4 bytes)\\
	Server public port (2 bytes)
\end{mybox}


\subsection{Map Loop}
Gets a servers map information.
\ClientRequest
\begin{mybox}
	Length of request (2 bytes)\\
	MAPLOOP\_REQUEST (1byte)\\
	Server public IP (4 bytes)\\
	Server public port (2 bytes)
\end{mybox}

\ServerResponse
\begin{mybox}
	Server public IP (4 bytes)\\
	Server public port (2 bytes)\\
	Map change time (4 bytes)\\
	Number of maps (1 byte)\\
	Map names (i bytes) [NTS string]
\end{mybox}

\subsection{Player Search}
Search a specific player information.
\ClientRequest
Total request length should less than 256 bytes.
\begin{mybox}
	Length of request (2 bytes)\\
	PLAYERSEARCH\_REQUEST (1 byte)\\
	Search options (4 bytes)\\
	Max results (4 bytes)\\
	Player name (i bytes)
\end{mybox}

\ServerResponse
Player names are NTS string.
\begin{mybox}
	Is final flag (1 byte)\\
	Result count (1 byte)\\
	Player names (i bytes)\\
	Server IP (4 bytes)\\
	Server ports (2 bytes)\\
	Last record UTC time (4bytes)\\
	Game name (i bytes)
\end{mybox}

\chapter{Server Info}
Retrieves server rules for a specific server.
\ClientRequest
\begin{mybox}
	Length of request message (2 bytes)\\
	SERVER\_INFO\_REQUEST (1 byte)\\
	Public IP of specific server (4 bytes)\\
	Public port of specific server (2 bytes)\\
\end{mybox}

\ServerResponse

\begin{mybox}
	
\end{mybox}






\part{SAKE Persistent Storage}
\part{ATLAS Competition}
\part{Voice Chat}
\part{Web Authentication}

\part{GameSpy Status \& Tracking}
\chapter{General Introduction}
\section{Note}
Game uses GSTATS to store its data only using email and passwords login method in GPCM. So we do not need to consider namespaceid, we only need to find profileid.


\section{Working Process}
\begin{enumerate}
	\item On startup, the host connects to tracking server, is authenticated, and is assigned a unique connection ID. If disk logging is enabled (see below) and there are logged games, they are sent to the tracking server. 
	\item When the actual game starts, the host sends a new game notification to the tracking server and creates internal structures for managing the game information. 
	\item During the game the host collects information into buckets (or developer's own data structures) and sends out snapshots at regular intervals (in case the host is reset before the game finishes) 
	\item (If player authentication is used) As players connect, the host sends out a challenge to the client, which formats a response based on its password or CD Key. This response is sent back to the host and stored as part of the snapshot. 
	\item When the game is complete, a final snapshot is sent to the tracking server. 
	\item A new game can be started immediately over the same connection (multiple simultaneous games over the same tracking server connection are supported as well). 
	\item The tracking server post-processes the data to extract some standard information and verify the authentication of the players. Disk logged or unusual games are marked for inspection. 
\end{enumerate}
\section{Message Encryption}
The GameSpy Stats \& Tracking (GSTATS) SDK provides a simple, secure way to report the results and statistics of games to a central server. These results can then be used to help facilitate online rankings, ladders, and tournaments. Tracking is done in a very abstract manner than can be applied to any type of multiplayer game.\\
The communication between client and GSTATS server is encrypted under an simple XOR method. After encrypted the message look like \ref{gstats encrypted message}.

\begin{mybox}[label = gstats encrypted message]
	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\tbs final\tbs
\end{mybox}


\section{Client Command}

\begin{table}[H]
	\centering
	\begin{tabular}{B}
		\hline
		\textbf{Command}&\textbf{Description}\\\hline
		auth~[\ref{gstats authentication}]& Authentication request\\\hline
		updgame&Sends a snapshot of information about the current game.\\\hline
		authp& Authenticates player\\\hline
		getpd& Gets persist data values modified\\\hline
		getpid& Ge sprofile id\\\hline
		newgame& Creates a new game for logging and registers it with the stats server.\\\hline
		
		
	\end{tabular}
\caption{GSTATS client request command}
\label{GSTATS client request command}
\end{table}
\section{Server IP and Port}

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Name}&\textbf{IP}&\textbf{Port}\\ 
		\hline 
		GSTATS&gamestats.gamespy.com&29920 (tcp) \\ 
		\hline 
	\end{tabular} 
	\caption{IP and Ports for GameSpy status and tracking}
	\label{IP and Ports for GameSpy status and tracking}
\end{table}


\chapter{Protocol Detail}
\section{Authentication}\label{gstats authentication}


\begin{figure}[H]
	\centering
	\begin{sequencediagram}
		\newthread{Client}{Client}{}
		\newinst[5]{GSTATS}{GSTATS}{}
		\begin{call}
			{Client}{Connect}{GSTATS}{Send challenge}
		\end{call}
		\begin{call}
			{Client}{Send challenge response}{GSTATS}{Accept/reject}
		\end{call}
	\end{sequencediagram}
	\caption{GSTATS authentication diagram}
\label{GSTATS authentication diagram}
\end{figure}
\ServerChallenge

\begin{mybox}
	\tbs challenge\tbs<challenge string>\tbs final\tbs
\end{mybox}


\ClientRequest

\begin{mybox}[label = gstats auth request]
	\tbs auth\tbs\tbs gamename\tbs<game name>\tbs response\tbs<response string>\\
	\tbs port\tbs<game port>\tbs id\tbs<operation id>\tbs final\tbs
\end{mybox}
The response string in\ref {gstats auth request} is computed using the secrete key~\ref{GameSpy Secret Key} of the client.\\

\ServerResponse

\begin{mybox}
	\tbs sesskey\tbs<session key>\tbs final\tbs
\end{mybox}

Session key should be Uint number.

when game wants to use the connect to GSTATS server, server will send an message to game which contains the challenge, the total length of message must bigger than 38bytes, and the challenge must bigger than 20bytes.
when game received the challenge it will compute a response, the response is formed as follows. 
response = CRC32(<server challenge>,<length of server challenge>)||<game secret key>
then game will compute the MD5 hash as MD5value = MD5(<response>,<length of response>)
then encoded with Enctype3
then construct the challenge-response message as $ \backslash auth \backslash \backslash gamename \backslash <gamename>\backslash response \backslash <MD5value> \backslash port \backslash <port> \backslash id \backslash <id> $

session key length (unknown)
connction id = transfer ascii of sessionkey to integer

the initialization phase is finished.
server challenge message length (bigger than 38-byte)
server challenge length (bigger than 20-byte)
$ \backslash final \backslash $ is not encrypted using XOR Enctype1 at the end of the challenge that sends by the server.

\section{Authenticate Player}

\subsection{Authenticate Player With Partner Information}
\ClientRequest
\begin{mybox}
	\tbs authp\tbs\tbs authtoken\tbs<authtoken string>\\\tbs resp\tbs response\tbs<response string>\tbs lid\tbs <local id>\tbs final\tbs
\end{mybox}
\ServerResponse

Server response is the same as \ref{gstats player auth server response}.
\subsection{Authenticate Player With Presence Connection Manager}
\ClientRequest
\begin{mybox}
	\tbs authp\tbs\tbs pid\tbs<profile id>\tbs resp\tbs<response string>\tbs lid\tbs <local id>\tbs final\tbs
\end{mybox}
\ServerResponse

Server response is the same as \ref{gstats player auth server response}.
\subsection{Authenticate Player With CD Key Hash}
\ClientRequest
\begin{mybox}
	\tbs authp\tbs\tbs nick\tbs<nick name>\tbs keyhash\tbs<cd key hash>\tbs resp\tbs <response string>\tbs lid\tbs<local id>\tbs final\tbs
\end{mybox}
\ServerResponse

Server response is the same as \ref{gstats player auth server response}.

The challenge response string here is calculated from password and the connection id.
xor challenge base string will be 0x38F371E6(decimal: 955478502)
\begin{mybox}
int temp = connid xor 0x38F371E6\\
string challenge;\\
string result;\\
for( int i=0; i<challenge.Lenth; i++ )\\
\{\\
	result+=( i + 17 + challenge[i]);\\
\}
\end{mybox}
the calculation for resopnse string is connid xor 0x38F371E6
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Game name}&\textbf{Secret key}\\\hline
		Crysis2&8TTq4M\\\hline
	\end{tabular}
	\caption{Player authenticate response string}
	\label{Player authenticate response string}
\end{table}

\ServerResponse

\begin{mybox}[label = gstats player auth server response]
	\tbs pauthr\tbs <profile id>\tbs lid\tbs <local id>\tbs final\tbs
\end{mybox}



\section{Get Profileid}
Client can get profile id by searching his cd-key hash in GSTATS server.
\ClientRequest
\begin{mybox}
	\tbs getpid\tbs\tbs nick\tbs <nick name>\tbs keyhash\tbs<cd key hash>\tbs lid\tbs <local id>\\\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}
	\tbs getpidr\tbs <profile id>\tbs lid\tbs<local id>\tbs final\tbs
\end{mybox}

\section{Get Player Data}
\ClientRequest
\begin{mybox}
	\tbs getpd\tbs\tbs pid\tbs<profile id>\tbs ptype\tbs<persist storage type>\tbs dindex\tbs <data index>\tbs keys\tbs final\tbs
\end{mybox}
\ServerResponse

\begin{mybox}
\tbs getpdr\tbs <profile id>\tbs lid\tbs<local id>\tbs mod\tbs<?>\tbs length\tbs<? length>\\\tbs data\tbs <player data>\tbs final\tbs
\end{mybox}

\begin{table}
	\centering
\begin{tabular}{|l|p{8cm}|}
	\hline
	\textbf{Enum name}&\textbf{Description}\\\hline
	pd\_private\_ro& Readable only by the authenticated client it belongs to, can only by set on the server.\\\hline
	pd\_private\_rw& Readable only by the authenticated client it belongs to, set by the authenticated client it belongs to.\\\hline
	pd\_public\_ro& Readable by any client, can only be set on the server.\\\hline
	pd\_public\_rw& Readable by any client, set by the authenicated client is belongs to.\\\hline
\end{tabular}
	\caption{Persist storage enumerator}
\label{Persist storage enumerator}
\end{table}

\section{New Game}
Creates a new game for logging and registers it with the stats server. 
Creates all the game structures, including buckets if needed.
\ClientRequest

\begin{mybox}
	\tbs newgame\tbs\tbs connid\tbs<connection id>\tbs sesskey\tbs<session key>\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}

\end{mybox}

\section{Set Persist Data Helper}
\ClientRequest
\begin{mybox}
	\tbs setpd\tbs\tbs pid\tbs<profile id>\tbs ptype\tbs <persist storage type> \tbs dindex\tbs<data index>\tbs kv\tbs<key value flag>\tbs lid\tbs <local id>\tbs length\tbs<size of game defined data>\tbs final\tbs
\end{mybox}

\ServerResponse

\begin{mybox}
	\tbs setpdr\tbs<success or fail>\tbs lid\tbs<local id>\tbs pid\tbs <profile id>\\\tbs mod\tbs <modified time>\tbs final\tbs
\end{mybox}

\section{Update Game Snapshot}
\ClientRequest

Old version:
\begin{mybox}
	\tbs updgame\tbs\tbs sesskey\tbs<session key>\tbs done\tbs<final flag>\\\tbs gamedata\tbs <game data>\tbs final\tbs
\end{mybox}

New version:
\begin{mybox}
		\tbs updgame\tbs\tbs sesskey\tbs<session key>\tbs connid\tbs<connection id>\\\tbs done\tbs<final flag>\tbs gamedata\tbs <game data>\tbs final\tbs
\end{mybox}

\ServerResponse

Server only records the data.


\chapter{GameSpy Persist Storage}
\section{Introduction}
If you store your data in key\value delimited pairs, GetPersistDataValues will
allow you to easily retrieve a subset of the stored data. To retrieve the entire
data set, use GetPersistData. The data will be returned as a null-terminated string,
unless no data is available (in which case len will be 0 in the callback).
\section{Parameter}
\begin{itemize}
	\item localid: Your game-specific reference number for this player, returned in the callback
	to allow you to identify which player it is referring to.
	\item profileid: The profileid of the player whose data you are looking up. 
	Returned by gpIDFromProfile() in the Presence \& Messaging SDK, or using GetProfileIDFromCD
\item	type: The type of persistent data you are looking up
\item	index: Each profile can have multiple persistent data records associated with them. Usually you
	just want to use index 0.
\item	modifiedsince: A time value to limit the request for data. Data will only be returned if it has been
	modified since the time provided. If data has not been modified since that time, the callback will be
	called with a success value that indicates it is unmodified.
Note: modification time is tracked for the given profileid/index, not on a per-persisttype or per-key basis
	keys: A "\tbs" delimited list of the keys you want returned (for example: "\tbs clan\tbs color\tbs homepage\tbs birthday")
	PersDataCallbackFn: Callback that will be called with the data when it is returned
	instance: Pointer that will be passed to the callback function (for your use)
\end{itemize}




\part{GameSpy Chat Server}

\chapter{Introduction}
GameSpy Chat server is similar to IRC chat server, but support many extra commands.
We use bracket <> to represent the data, in real protocol there is no bracket around each character field.\\
For example the following codes shows a welcome message.
\begin{mybox}
	:www.retrospy.cc 001 spyguy  :"Welcome to RetroSpy".
\end{mybox}
The client request formatted as follows:
\begin{mybox}[label= Format of the GameSpy chat request]
	:<prefix> <middle> <command> <command params> :<tailing> \tbs r\tbs n
\end{mybox}
\section{Prefix Format}
:<prefix> contains information as follows, when user is logged in the prefix will have user's information and server address. Before user logged in there will be only server address. Prefix using to indicate the message source.
\begin{mybox}
	:<nick name>!<user name>@<server address>\\
	or\\
	:<server address>
\end{mybox}
\section{Middle Format}
In original IRC protocol, <middle> is used to represent the <command> and <command parameters>, however in GameSpy chat protocol they comprehend it a parameter before <command>, which cause the handler of sdk some time skip the first parameter. The partial source code of \tbf{ciRplGetCKeyHandler()} we list as follows.
\begin{mybox}
	channel = message->params[1];\\
	nick = message->params[2];\\
	cookie = message->params[3];\\
	flags = message->params[4];
\end{mybox}


\section{Command Format}
GameSpy chat protocol contains two types of command, request is character command, response has both types of command.
\begin{itemize}
	\item Enumerate command
	\item Character command
\end{itemize}

\subsection{Enumerate Command}
The format of enumerate commands are present as three digit numbers \tbf{XXX}. The commands which used by GameSpy chat server are list as Table~\ref{The enumerate reply command}.
\begin{table}[H]
	\centering
	\begin{longtable}{|p{4.5cm}|l|p{4.5cm}|}
		\hline 		\tbf{Name}&\tbf{Value}&\tbf{Description}\\
		\hline
		RPL\_WELCOME&"001"&Welcome reply\\
		\hline
		RPL\_USRIP           &        "302"&Get user's public ip reply\\\hline
		RPL\_WHOISUSER        &       "311"&Search for user information reply\\\hline
		RPL\_ENDOFWHOIS         &     "318"&End of search user information reply\\\hline
		RPL\_WHOISCHANNELS     &      "319"&Search channel information reply\\\hline
		RPL\_LISTSTART         &      "321"&Start list channels reply\\\hline
		RPL\_LIST               &     "322"&List channel information reply\\\hline
		RPL\_LISTEND       &          "323"&End of list channel information reply\\\hline
		RPL\_CHANNELMODEIS     &      "324"&Get channel modes reply\\\hline
		RPL\_NOTOPIC     &            "331"&There is no topic for this channel reply\\\hline
		RPL\_TOPIC              &     "332"&Get channel topic reply\\\hline
		RPL\_WHOREPLY        &        "352"&Search users reply\\\hline
		RPL\_ENDOFWHO          &      "315"&The end of Search users reply\\\hline
		RPL\_NAMEREPLY         &      "353"&Get users in channel reply\\\hline
		RPL\_ENDOFNAMES     &         "366"&End of list users in this channel reply\\\hline
		RPL\_BANLIST              &   "367"&Get ban list reply\\\hline
		RPL\_ENDOFBANLIST      &      "368"&End of ban list reply\\\hline
		RPL\_GETKEY              &    "700"&Get user value by specific keys reply\\\hline
		RPL\_ENDGETKEY      &         "701"&End of GETKEY reply\\\hline
		RPL\_GETCKEY           &      "702"&Get channel or user's values reply\\\hline
		RPL\_ENDGETCKEY    &          "703"&End of GETCKEY reply\\\hline
		RPL\_GETCHANKEY     &         "704"&Get channel values reply\\\hline
		RPL\_SECUREKEY       &        "705"&Use gamespy encryption to communicate\\\hline
		RPL\_CDKEY               &    "706"&Authenticate with cdkey reply\\\hline
		RPL\_LOGIN              &     "707"&Login as a GameSpy user reply\\\hline
		RPL\_GETUDPRELAY		&		"712"&\\\hline

	\end{longtable}
\caption{The enumerate reply command}
\label{The enumerate reply command}
\end{table}

The 3 digits number will convert to ASCII code and send to client.


\subsection{Character Command}
The other command is character command, the format of these commands are using words to represent command.

\begin{table}[H]
	\centering
	\begin{tabular}{|p{4.5cm}|l|p{4cm}|}
	\hline 		\tbf{Name}&\tbf{Value}&\tbf{Description}\\\hline
	
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{|p{4.5cm}|l|p{4cm}|}
	\hline 		\tbf{Name}&\tbf{Value}&\tbf{Description}\\\hline
	Private message response&"PRIVMSG"&\\\hline
	Notice message response&"NOTICE"&\\\hline
	Under the table message response&"UTM"&\\\hline
	Above the table message response&"ATM"&\\\hline
	Ping message response&"PING"&\\\hline
	Nick message response&"NICK"&\\\hline
	Join channel response&"JOIN"&\\\hline
	Leave channel response&"PART"&\\\hline
	Kick player response&"KICK"&\\\hline
	Quit response&"QUIT"&\\\hline
	Kill response&"KILL"&\\\hline
	Get or set topic response&"TOPIC"&\\\hline
	Get or set mode response&"MODE"&\\\hline
	Error message&"ERROR"&\\\hline
	Invite Response&"INVITE"&\\\hline
	\end{tabular}
\caption{Character reply commands}
\label{Character reply commands}
\end{table}

\section{Command Parameters}
Command parameters are the extra information that each request contains. Such as nick name, user name, channel name etc.

\section{Tailing Format}
The start of <tailing> should be :, the space inside <tailing> is ignored by server and client, which means you can send <:hello my friend> to others. usually <tailing> is used to carry some messages.
%    \s\su\sub\subs\subse
%\begin{figure}
%	\centering
%	\begin{tikzpicture}
%		\begin{package}{Architecture}
%		
%			\begin{class}[text width = 4cm]{ChatServer}{0,0}
%			\attribute{String[9] : Name}
%			\operation{+ CreateChatSession()}
%			\operation{+ CreateChatChannel()}
%			\end{class}
%			
%			\begin{class}[text width = 3cm]{ChatSession}{5,-10}
%			\end{class}
%			
%			\begin{class}[text width = 4cm]{ChatUser}{5,-5}
%			\attribute{ChatSession : Session}
%			\attribute{ChatChannel[] : Channels}
%			\end{class}
%	
%
%			\begin{class}[text width = 4cm]{ChatChannel}{-5,-5}
%			\operation{+ AddChatUser()}
%			\operation{+ DeleteChatUSer()}
%			\operation{+ BanChatUser()}
%			\end{class}
%			
%			\composition{ChatServer}{}{}{ChatUser}
%			\composition{ChatServer}{}{}{ChatChannel}
%			\aggregation{ChatUser}{}{}{ChatChannel}
%			\composition{ChatUser}{}{}{ChatSession}
%		\end{package}
%	\end{tikzpicture}
%\end{figure}
%
%multiple commands can send with one message
%
%\begin{figure}
%	\begin{tikzpicture}
%		\begin{package}{IRC Command System}
%		\begin{class}[text width=4cm]{IRCCommandBase}{0,0}
%		\attribute{String : Prefix}
%		\attribute{Enum : Command}
%
%
%		\attribute{String[15] : Params}
%		\operation{+ IRCCommandBase[] GetCommands(string request)}
%		\end{class}
%
%		\begin{class}[text width=4cm]{IRCUserCommand}{-5,-5}
%		\inherit{IRCCommandBase}
%		\end{class}
%		
%		\begin{class}[text width=4cm]{IRCServerCommand}{0,-5}
%		\inherit{IRCCommandBase}
%		\end{class}
%		
%		\begin{class}[text width=4cm]{IRCChannelCommand}{5,-5}
%		\inherit{IRCCommandBase}
%		\end{class}
%		\end{package}
%	\end{tikzpicture}
%\end{figure}
%
%\begin{figure}
%	\centering
%	\begin{tikzpicture}
%	\begin{package}{IRC Command Handler}
%	\begin{class}{CommandHandlerBase}{0,0}
%	\attribute{IRCCommand : command}
%	\end{class}
%	\begin{class}[text width=4cm]{ACommandHandler}{3,-3}
%	\inherit{CommandHandlerBase}
%	\attribute{IRCCommand : command}
%	\end{class}
%		\begin{class}[text width=4cm]{BCommandHandler}{-3,-3}
%	\inherit{CommandHandlerBase}
%	\attribute{IRCCommand : command}
%	\end{class}
%	\end{package}
%	\end{tikzpicture}
%\end{figure}
%
%\begin{figure}
%	\centering
%	\begin{tikzpicture}
%	\begin{package}{IRC Channel System}
%	\begin{class}{IRCChannel}{0,0}
%	\attribute{String : Mode}
%	\attribute{String : Name}
%	\attribute{ChatSession[] : Users}
%	\end{class}
%	\end{package}
%	\end{tikzpicture}
%\end{figure}

\begin{appendix}
\chapter{Login Proof Challenge Generation Algorithm}\label{Login Proof Challenge Gerneration Algorithm}
\chapter{Gstats Initial Encryption}
\chapter{CDKey Server Initial Encryption}
\chapter{GameSpy Secret Key}\label{GameSpy Secret Key}
If a game is using GameSpy service, GameSpy will issue  a secret key to the game, which length is at 5-byte. The secret key that GameSpy issued is not the traditional secret key in public-key cryptography, actually it is an key for simple symmetric encryption.
\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Game name}&\textbf{Secret key}\\\hline
		Crysis2&8TTq4M\\\hline
  \end{tabular}
\caption{Secret key example}
\label{Secret key example}
\end{table}
\end{appendix}


\end{document}
